{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f30\froman\fcharset238\fprq2 Times New Roman CE;}{\f31\froman\fcharset204\fprq2 Times New Roman Cyr;}
{\f33\froman\fcharset161\fprq2 Times New Roman Greek;}{\f34\froman\fcharset162\fprq2 Times New Roman Tur;}{\f35\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f36\froman\fcharset178\fprq2 Times New Roman (Arabic);}
{\f37\froman\fcharset186\fprq2 Times New Roman Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;
\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{
\s15\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \i\fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 \sbasedon0 \snext15 Body Text;}}{\*\listtable{\list\listtemplateid-2000782110\listhybrid{\listlevel\levelnfc0
\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid67698703\'02\'00.;}{\levelnumbers\'01;}\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1\fbias0 \fi-360\li720\jclisttab\tx720 }{\listlevel
\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid67698713\'02\'01.;}{\levelnumbers\'01;}\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-360\li1440\jclisttab\tx1440 }{\listlevel
\levelnfc2\levelnfcn2\leveljc2\leveljcn2\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid67698715\'02\'02.;}{\levelnumbers\'01;}\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-180\li2160\jclisttab\tx2160 }{\listlevel
\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid67698703\'02\'03.;}{\levelnumbers\'01;}\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-360\li2880\jclisttab\tx2880 }{\listlevel
\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid67698713\'02\'04.;}{\levelnumbers\'01;}\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-360\li3600\jclisttab\tx3600 }{\listlevel
\levelnfc2\levelnfcn2\leveljc2\leveljcn2\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid67698715\'02\'05.;}{\levelnumbers\'01;}\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-180\li4320\jclisttab\tx4320 }{\listlevel
\levelnfc0\levelnfcn0\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid67698703\'02\'06.;}{\levelnumbers\'01;}\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-360\li5040\jclisttab\tx5040 }{\listlevel
\levelnfc4\levelnfcn4\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid67698713\'02\'07.;}{\levelnumbers\'01;}\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-360\li5760\jclisttab\tx5760 }{\listlevel
\levelnfc2\levelnfcn2\leveljc2\leveljcn2\levelfollow0\levelstartat1\levelspace0\levelindent0{\leveltext\leveltemplateid67698715\'02\'08.;}{\levelnumbers\'01;}\chbrdr\brdrnone\brdrcf1 \chshdng0\chcfpat1\chcbpat1 \fi-180\li6480\jclisttab\tx6480 }{\listname 
;}\listid2100784375}}{\*\listoverridetable{\listoverride\listid2100784375\listoverridecount0\ls1}}{\info{\title The quickest, least-code approach would be to use one of the built-in ODE spaces (perhaps new SAP space)}{\author J. Perkins}
{\operator J. Perkins}{\creatim\yr2006\mo3\dy27\hr15\min55}{\revtim\yr2006\mo3\dy29\hr15}{\version16}{\edmins233}{\nofpages4}{\nofwords1451}{\nofchars8275}{\*\company AstraZeneca}{\nofcharsws0}{\vern8229}}
\widowctrl\ftnbj\aenddoc\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\hyphcaps0\formshade\horzdoc\dgmargin\dghspace180\dgvspace180\dghorigin1800\dgvorigin1440\dghshow1\dgvshow1
\jexpand\viewkind1\viewscale75\pgbrdrhead\pgbrdrfoot\splytwnine\ftnlytwnine\htmautsp\nolnhtadjtbl\useltbaln\alntblind\lytcalctblwd\lyttblrtgr\lnbrkrule \fet0\sectd \linex0\endnhere\sectlinegrid360\sectdefaultcl {\*\pnseclvl1
\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5
\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang
{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1033\langfe1033\cgrid\langnp1033\langfenp1033 {
The quickest, least-code approach would be to use one of the built-in ODE spaces (perhaps new SAP space). This would also allow me to leverage any work done on these spaces. The drawback is that I will need to keep a hashtable to map geom pointers to C# o
bjects for the near callback.
\par 
\par At some point I will need a spatial database anyway for visibility and similar queries, and it might be worth leveraging it for collision detection as well. This database may well just be a port of one of the existing spaces to C#.
\par 
\par I don\rquote t think there are any additional drawbacks to this approach.
\par 
\par So on the fixed update, the collision system triggers a test. The near callback gets called, which generates one or more messages to the actors involved. This seems perfectly reason
able. If I end up writing my own spatial database later on, it should be a transparent change.
\par 
\par So what this means is that the collison subsystem will keep a space internally and add all geoms to it (and remove them when they get disposed or gc\rquote ed). The co
llision subsystem will hook the fixed update call and run the test. The near callback will trigger the exact test along with any messages that need to be sent to the actor (perhaps a precollide and message to allow the collision to be skipped).
\par 
\par }{\b Collision Groups (suppressing collisions between entity parts)}{
\par 
\par What about the vehicle case? Here I have several different actors joined together. I want to prevent contacts from being generated between the wheels and the chassis, since their simple bounding shapes 
will almost always overlap. Thinking this through: the simulation will load the vehicle actor file, which will have a root \'93vehicle\'94
 actor that contains all the others. The simulation could put a space into the root actor, and then any geoms found during l
oaded could be shoved into this space. However, the space would have to get added after the fact, right? Hmm, well it is true that I could do some post-processing on the vehicles. 
\par 
\par So I call LoadActor(filename) to load the vehicle (or somesuch). I get bac
k an actor tree. At this point, any geoms that were loaded are in the global space. Now, in an earlier session I thought that I could add a ParentActor property that would point to the root (at load time) actor, and that I could prevent geoms that belonge
d to the same parent actor from colliding. But that\rquote s not so good if I have dynamic objects in my map file, since they would not be able to collide with anything else in the map! I need a better solution.
\par 
\par If multiple geoms are added to the same actor, they should not generate collisions with each other. Geoms should only interact when they belong to separate actors, which makes sense. 
\par 
\par If geoms have a joint between them (as they will for the ODE based dynamics components) no contact is generated.
\par 
\par My ideas so far boil down to:
\par {\listtext\pard\plain\hich\af0\dbch\af0\loch\f0 1.\tab}}\pard \ql \fi-360\li720\ri0\widctlpar\jclisttab\tx720\aspalpha\aspnum\faauto\ls1\adjustright\rin0\lin720\itap0 {
A collision group behavior that collects geoms from all child actors (geoms in current actor already ignore collisions)
\par {\listtext\pard\plain\hich\af0\dbch\af0\loch\f0 2.\tab}?
\par }\pard \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 {
\par What if all geoms looked up the actor tree to find a space to live in? The scene root actor would contain the \'93master\'94
 space with internal collision enabled. The vehicle would contain a subspace with internal collisions disabled. The plumbing for this could get wacky. And how does the vehicle get a subspace attached? Who does that and how? Is this automatic for all
 actors? What about maps?
\par 
\par If I use a subspace, I can avoid the broad phase tests and callbacks between the vehicle parts, which is good.
\par 
\par If a wheel is both a pose and a shape (based on radius and width), does that gain me anything? If a chassis is both a
 pose and a trimesh, does that help? Now the behavior is also creating the shape and can set parameters on it (how that works under the hood is TBD). Well, presumably I could set a flag to prevent these collisions. I might be able to set a \'93
collision parent actor\'94 and anything that falls under that actor gets ignored.
\par 
\par Think of another case: an FPS character holding a weapon. I don\rquote t want to test the bounding box of the weapon against the character capsule. So now what? Maybe I need the concept of a root or
 parent actor. This flag could be automatically set in the editor on the root actor node. Collisions do not occur between objects that have the same parent. Is there a way to make this work for maps? There I may have animated objects, say a crate that can
 be run into and knocked around. The crate must collide with the other objects in the scene. Well, I could say that the }{\i scene}{
 root does not have the flag, so there is no shared parent and the objects could collide. Or I could say the parent is one down from the scene root. 
\par 
\par I could put a flag on an actor that says \'93enable sub-actor interactions\'94. That\rquote s ugly and vague but it could work.  But none of this gets me to the point of having subspaces to encapsulate non-interacting geoms. 
\par 
\par When I create a new scene in the editor, the root actor always has a shape group attached to it. You can enable or disable collisions within a shape group, defaulting to disabled. If I treat the root node as a \'93scene\'94
, I could even put some special properties on it that don\rquote t ap
ply to sub-actors. Now when geoms are connected to a scene they scan up the tree looking for a space to which to add themselves. When they are removed from a scene they pull themselves out of the space as well (here\rquote 
s yet another place for a weak reference).
\par 
\par While completely arbitrary hierarchies are possible, in reality there is a root scene, and then actors underneath that. That second level actor could get special treatment, and I could even have \'93Create new scene\'85\'94 and \'93Create new actor\'85
\'94 in the editor to distinguish between the two there, if necessary.
\par 
\par The case of the chain is interesting. Here I have a single actor \'93chain\'94 that contains a bunch of visuals and geoms connected by joints. Using actors is probably too inefficient for this, it might be wo
rth creating a special data structure for this, but I will come back to that. In this case, I need collisions between all of these subactors. 
\par 
\par I don\rquote t see any way that I can deduce the correct behavior automatically. Chains require internal collisions, ve
hicles and characters do not. Maybe later on I will have an exact trimesh for the chassis and I will want internal collisions for vehicles too. Maybe I\rquote 
ll want wheels to collide with the chassis but not suspension parts. Too many permutations! Reboot!
\par 
\par Sta
rt simple: a player character holding an item. I would need some logic to attach the item to the player model, and that same logic could filter the contacts. How would it do that? The item would probably not be a subactor, though it could be. A behavior o
n the player would have to know about the item being held. If subactor collisions were automatically suppressed that would be all I needed to do. 
\par 
\par I don\rquote t like needed to say create new scene/actor. I\rquote d rather just start out with an empty document and start adding things.
\par 
\par So someone creating a chain will  a template for a single link. Then they will drop a bunch of these into a parent actor, and then create joints between them. Voila, this is great. I don\rquote t want two connected links to contact, and the joint
 test in the dynamics subsystem will take care of that. I do want non-connected links to contact. Maybe }{\i this}{ is the case where I want to add a collision space to the parent? That might be backwards, but it is more intuitive to the designer. 
\par 
\par I could put a flag on the geom that says ignore collisions from this actor, siblings, children, etc. In the case of a vehicle, the geom is automatically added and these flags can be set. This isn\rquote 
t as efficient as have a space (although maybe I could synthesize it) but it would work.
\par 
\par So a geom has flags: collide with actor, collide with siblings, collide with children, and whatever else I think up. By default, a geom will collide with siblings and maybe children if I have that flag, but not within the same actor.  
\par 
\par 
\par }{\b How does the collision shape get it\rquote s pose updated?
\par }{
\par One way would be to listen for a MovedMessage, like I did in the prototype. This message would need to be sent on the next FixedUpdate after it changes in order to effect the next collision detection pass
 (or any logic that runs on the fixed step). I could send the message as soon the pose changes but if the logic is going to change both position and orientation then two messages would get sent, and I\rquote m not sure that\rquote 
s what I want. So every fixed update, w
hich means that every pose in the system needs to register for that update, or it needs to constantly add/remove itself from the list (possible). Or I would need to keep a dirty list somewhere, maybe as  a static list inside the base pose class that gets 
sent on a single fixed update call. Something. Rigid bodies could do this, keep a list, keep track of who is sleeping, and send updates.
\par 
\par The alternative is to have the collision shape (and anything else) pull from the pose as needed, and that\rquote s a viable ap
proach too. But this needs to be done before each collision pass to ensure that the internal broadphase culling has the right positions. If most poses in the scene are static, this would result in more messages getting sent than necessary.
\par 
\par Maybe I will have the static poses send the message as soon as they are updated\'85but how would I know? I\rquote 
ve exposed position and orientation as fields, which I prefer. But that means that I have no way to know when they have changed. Which means every single pose in the system must get every fixed update call, even if they never change.  So\'85
I can put the position and orientation back behind properties, with some docs to warn people how they work. Boy, I would really prefer a field.
\par 
\par I could make Position and Orientation in
to classes? That would make the properties appear more like a field to the user. It is true that Pose.Position and Pose.Orientation could use something other than the Position and Orientation class, and just translate as needed?  Bah. Make it a property o
n IPose and provide helper functions for setting. Stinks but I can always revisit it later. With that in place, poses can send a message immediately when moved, and I don\rquote 
t need fixed updates going everywhere. Rigid bodies are still an issue but I can deal with that.
\par 
\par }{\b How would I implement a chain (one actor with lots of interacting geoms)?
\par 
\par How is collision space managed?}{
\par 
\par When a geom is created, it should automatically be in the space. Even when it is added to an actor it is not necessarily part of the sce
ne. Do I care? Should it start receiving messages as soon as it is created? Can I update one scene and not another?  No, scenes update at the same time, but it is true that geoms from one scene should not interact with geoms from a different scene. If I a
m going to support the concept of separate scenes (should I?) I need to handle this case. I think I should simplify to a single scene. But the question remains: when do I add a geom to the global space?
\par 
\par It needs to get added when its actor is attached to the scene, and removed when it or its actor is removed from the scene. Start
 and Stop messages would make sense here. When an actor is added to another actor, I would need to see if it was part of the scene. I shouldn\rquote t send the Start message until the whole scene is built and ready to go, but where does that get fired? 
I could call it from Framework.Tick() before I do anything else\'85not too bad.
\par 
\par }}