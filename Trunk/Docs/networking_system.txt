Collection of data from object could be automatic using reflection, then packed into a message and sent. Tie this into object roles to support different topologies. Object would be able to override to optimize data.

What constitutes a relevant object? Visible, audible, collidable. Ties into a number of subsystems.

---------------------------------------------------------------------

## References ##
* http://www.opentnl.org/
* http://www.rakkarsoft.com/
* http://www.zoidcom.com/
* http://zige.sourceforge.net/
* http://irmo.sourceforge.net/
* http://www.hawksoft.com/hawknl/ 
* http://www.quazal.com/ 
* http://www.replicanet.com/


* http://www.gaffer.org/articles/NetworkedPhysics.html 
  * (seems to require ability to advance single objects, no dWorldStep).
* http://www.cmpevents.com/sessions/GD/ACaseForMessagePassingArchitectures.ppt

##### Military References #####

* http://www.npsnet.org/~zyda/pubs/Presence.3.4.pdf
* http://www.sics.se/dive/

---------------------------------------------------------------------

ReplicaNet keeps networking completely hidden. There is a central "master" (the server but could be anywhere) for each object. When an object changes state it notifies the master which passes along the state change. Attributes on the values allow for prediction. Utilitize a session interface that can trigger events when users join or leave. Session controls topology (client-server or peer-to-peer). Supports multiple servers working peer-to-peer with players as clients.

Transmission types:

* Reliable: must arrive and in order
* Certain: must arrive but order is not important
* Unreliable: may or may not arrive at all

A string table allows common strings (filenames, player names, etc.) to be sent with just an ID. Each client has same ID for string so you can also use them for player identification, for instance.

Need a scoping system to determine which objects are important to the client. Objects that are out of scope do not need to be updated.

Provide attributes to specify additional information on values, such "this int field really only uses 12 bits", or "this holds values from 0-MaxHealth".

If I can run the client-side prediction model on the server I can determine when they are diverging (perhaps even look into the future) and schedule updates accordingly. However, I read that extrapolation of a full physics sim is difficult and might be best avoided. Can I run full physics on the client and use that as extrapolation? And send regular updates instead of looking for divergence? Here is where being able to step an individual object would be good: when I receive an update I could place the object accordingly and then step it forward to catch up.

Maybe each physics object should keep snapshots of its historical state. So when I get a server update I can compute the amount of error, and then adjust my current state by that amount. Don't know, would have to try it. Might need a way to send the state for an entire physics island (multiple bodies in contact) for this to work well. I can interpolate between stored states so I wouldn't need too many I think. I'm reading that this might be necessary; it might be enough to synchronize the scene to the most recent server update and then predict forward from there. So the scene objects will have a slight lag behind reality but on a good connection it might be easy and workable. An error correcting approach could get me closer though. If the server data and the client data get too far out of whack I could just dump the client state entirely to avoid crazy post-collision behavior for instance. Could I just advance the body using the last valid accelerations?

Chris Butcher mentions "we select between a few simple corrective techniques which try to match state by applying velocity impulses, with teleportation as a last resort."

"Clients deal with state lagged by 1/2 round-trip time behind the server, allowing for interpolation instead of extrapolation." Meaning that the client tends to get updates for a future state, and then can try to move toward that state. But what happens if update doesn't show up? This also means that player updates come from the past; do I just apply them when they show up?

If the server runs slightly ahead of the clients it might help. How to handle user input though?

Tough case will be joined bodies, like a tractor-trailer or two players that somehow become attacahed. The updates for all bodies involved would have to be sent in one shot.

"Important Moves" means attach all important data to every packet sent until you get an ack. Each package is numbered, and important data is marked with the packet to which it was attached. When an ack arrives all important moves before than ID can be discarded. The redundancy avoids the need to retransmission of packets. Because important moves are always received in order they can be delta-encoded (a1-a2=v) to reduce bandwidth.

I'm really concerned with maintaining state of "actors". My vehicles are implemented as as a single actor with a single body object. I need to keep that body object in sync on all clients. I also need to sync the internal shapes but that is less important.

All input must be handled on the server. 

Use UDP and construct a reliable-when-needed transport on top of that. This is where "important moves" comes in. The notion that TCP might wash out at the same speed is disproven by Tom Hubina. Keep packets small and send a lot of updates so probability increases that one will get through.

Need to monitor traffic to determine the bandwidth of the connection. (From Chris Butcher Halo 2) Monitor RTT, data throughput, and packet loss over a window of 2-5 seconds. If any value crosses a threshold start backing off the data rate. Over time can try to slowly ramp back up. Save values as a starting point for next session.

Use different object types: full dynamics on server, simpler proxy on client. Like Unreal, roles should be based on current session type (single player, local host, remote host). Scenery objects should be fully simulated on client always.

